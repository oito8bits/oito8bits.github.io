---
layout: post
title:  "Memória no Linux"
date:   2024-09-06
categories: C Linux OSDev
usemathjax: true
---

# 1 - Memória

A memória é um dos componentes mais importantes de um computador. Isso reflete na variedade de memórias presentes, atualmente (registradores, cache, RAM, etc), e suas características distintas. Algumas precisam ser gerenciadas para que sejam utilizadas de forma inteligente. Um exemplo disso é a RAM, uma vez que ela é limitada e existem vários processos que precisam desse recurso.

A memória pode parecer linear e simples quando você acessa, por exemplo, uma área alocada pela malloc(). Mas, por trás dos panos, a memória é algo complexo: precisamos separar áreas de código e dados, e evitar que ambos colidem um com outro; as informações armazenadas se fragmentam com facilidade; processos não podem acessar o espaço de endereço de outro. Existem vários outros problemas, porém apenas citei os mais comuns. Podemos utilizar de facilidades disponibilizadas pelo hardware e algoritmos/técnicas para minimizar ou resolver os problemas acima.

Atualmente, abstrações de hardware como a paginação é um exemplo de recurso que podemos usar para mapear e descrever memória. Algoritmos de alocação como o Buddy System e Slab organizam a memória de forma que ela possa ser utilizada da melhor forma possível. Esses mecanismos, juntos, são essenciais para o gerenciamento da memória por um kernel.

Portanto, a partir do que foi dito acima, a simples ação de armazenar bits é mais complexa do que parece. O entendimento disso tudo isso possibilita que o programador conheça as bases de um kernel, dos recursos gerenciados por esse tipo de software e da arquitetura do processador. Esse conhecimento pode ajudar no desenvolvimento de software que lidem com isso, seja em nível de kernel ou usuário.

# 2 - Arquitetura

Cada arquitetura de processador tem sua própria maneira de lidar com a memória. No caso do x86, é fornecido uma abstração em nível de hardware chamada de paginação. Alguns esquemas como a segmentação veio bem antes, mas teve que ser substituída, uma vez que tinha vários problemas como o limite de memória endereçável, por exemplo. Por outro lado, o ARM também usa paginação, mas tem sua própria maneira de tratar isso, então vamos focar apenas na arquitetura x86-64, já que falar de duas ou mais arquiteturas estenderia muito o artigo.

Com a paginação, a memória é organizada em páginas, que é um bloco de memória, geralmente, de 4 KiB, em sistemas Linux. O tamanho de uma página influencia várias outras partes do sistema. Um exemplo disso é o sistema de arquivos Ext, que organiza a memória no disco em blocos de 4 KiB. Existem também outros tamanho de páginas, no entanto falaremos disso nos próximos tópicos.

A página é acessada por meio de um endereço linear, onde o tamanho pode variar dependendo do modo de operação do processador. Esse endereço é convertido, pela MMU, para um endereço físico, que em alguns casos pode ou não ser igual ao endereço linear. Essa conversão precisa de uma estrutura hierárquica, na qual irá descrever um conjunto de tabelas e páginas.

# 2.1 - Paginação de 32 bits

A paginação, no modo protegido, pode ser ablitada setando o bit PG do registrado CR0. Em sistemas UEFI, ela já vem ativada por padrão. Além disso, o endereço linear é igual ao físico. Isso é chamado de mapeamento 1:1.

Na paginação de 32 bits, podemos usar apenas páginas com 4 KiB e 4 MiB de tamanho. Isso influencia bastante na forma como é organizado o endereço linear. A Figura 2-1 exibe o endereço linear para páginas de 4 KiB.

{% include image_description.html src="/assets/img/mm/virtual_address_format.png" caption="Figura 2-1: Formato do endereço linear para páginas de 4 KiB" %}

Todo o endereço linear tem 32 bits de tamanho. Cada campo nesse endereço é um índice em uma tabela. Veja também que cada campo tem um tamanho em bits. Esses tamanhos não foram escolhidos por acaso, mas sim para utilizar, sem desperdício, cada bit.

A especificação diz que o endereço linear pode ser traduzido para um endereço físico de 40 bits de tamanho. É fato que 40 bits podem endereçar até 1 TiB ($$2^{40} = 1099511627776$$) de memória, mas não podemos ter isso tudo de memória RAM, então esse tamanho de endereço nem chega a ser 40 bits.

Precisamos que parte do endereço linear seja usada como um deslocamento dentro de uma página. Os primeiros 12 bits (11:0), que são reservados para o _Offset_, servem exatamente para isso, pois 12 bits ($$ 2^{12} $$ = 4096) é o suficiente para endereçar uma página inteira. Quanto ao _Table_, ele é um índice em uma _Page Table_, tabela usada para descrever páginas. Cada entrada nessa tabela vai dizer o endereço físico, permissões de acesso e outros atributos da página descrita pela entrada. Note que o _Table_ tem apenas 10 bits ($$ 2^{10} = 1024 $$), então uma tabela pode ter apenas 1024 entradas. O _Directory_ também é um índice e pode ter até 1024 entradas, mas nesse caso ele irá descrever uma _Page Directory Table_, tabela onde cada entrada aponta para uma _Page Table_. Isso tudo forma a hierarquia de tabelas que falei acima (Veja a figura 2-2).

Se você fizer um cálculo rápido verá que é possível endereçar até 4 GiB:

$$
2^{10} \cdot 2^{10} \cdot 2^{12} = 4294967296 = 4 \text{ GiB}
$$

Esse é o motivo do seu processador de 32 bits poder usar apenas 4 GiB de RAM. A coisa complica um pouco mais, porque cada entrada nessa tabela tem 4 bytes de tamanho, istó é, cada Directory Table e Page Table tem, no máximo 4 KiB de tamanho ($$4 \cdot 1024 = 4096$$). Para descrever 4 GiB, precisamos de mais ou menos 4 MiB de tabelas:

$$
(2^{10} \cdot 2^{10} + 2^{10}) \cdot 4 = 4198400 \approx 4 \text{ MiB}
$$

Veja que $$2^{10} \cdot 2^{10} + 2^{10}$$ são todas as entradas de _Page Tables_ e _Directory Tables_ necessárias para mapear 4 GiB. Depois é multiplicado por 4 para calcular o tamanho em bytes das tabelas. 

{% include image_description.html src="/assets/img/mm/paging_structure.png" caption="Figura 2-2: Estrutura de paginação" %}

Essa PDE (_Page Directory Entry_) é uma entrada na _Directory Table_. Cada entrada tem uma estrutura (Veja a Tabela 2-1) com flags e o endereço físico da _Page Table_. O endereço da Page Table precisa estar alinhado em 4 KiB, então os 12 primeiros bits são zerados. A Intel aproveitou parte desses bits e usou eles como flags. O mesmo vale para a PTE (_Page Table Entry_), mas em vez de apontar e descrever uma tabela, ela faz isso para uma página (Veja a Tabela 2-2).

| Posição | Conteúdo |
|---------|----------|
| 0 (P)   | Se esse bit for igual a 1, então apágina está presente e pode ser usada. Se for igual a 0, não pode ser usada. |
| 1 (R/W) | Se for 0, a página não tem permissão de escrita. |
| 2 (U/S) | Se for 0, não é permitido acesso em modo usuário. |
| 3 (PWT) | Não falaremos dessa flag agora. |
| 4 (PCD) | Não falaremos dessa flag agora. |
| 5 (A)   | Indica se essa página foi acessada. |
| 6       | Ignorado. |
| 7 (PS)  | Esse bit deve ser 0 e o CR4.PSE = 1 para que essa entrada descreva uma Page Table. |
| 11:8    | Ignorados. |
| 31:12   | Endereço físico da página. |

<p style="text-align: center;"><em>Tabela 2-1: Entrada da PDE para descrever uma página de 4 KiB.</em></p>

| Posição | Conteúdo |
|---------|----------|
| 0 (P)   | Se esse bit for igual a 1, então apágina está presente e pode ser usada. Se for igual a 0, não pode ser usada. |
| 1 (R/W) | Se for 0, a página não tem permissão de escrita. |
| 2 (U/S) | Se for 0, não é permitido acesso em modo usuário. |
| 3 (PWT) | Não falaremos dessa flag agora. |
| 4 (PCD) | Não falaremos dessa flag agora. |
| 5 (A)   | Indica se essa página foi acessada. |
| 6 (D)   | Indica se essa página foi escrita. |
| 7 (PAT) | Não falaremos dessa flag agora. |
| 8 (G)   | Não falaremos dessa flag agora. |
| 11:9    | Ignorados. |
| 31:12   | Endereço físico da página. |

<p style="text-align: center;"><em>Tabela 2-2: Entrada da PTE para descrever uma página de 4 KiB.</em></p>

A coisa muda um pouco quando precisamos lidar com páginas de 4 MiB, porque são necessários 22 bits ($$2^{22} = 4194304 = 4 \text{ MiB}$$). Isso será permitido apenas se o bit PS da PDE for igual a 1 (Veja a Tabela 2-1). A Figura 2-3 mostra como é organizado o endereço virtual para páginas de 4 MiB.

{% include image_description.html src="/assets/img/mm/paging_structure_4mib.png" caption="Figura 2-3: Formato do endereço linear para páginas de 4 MiB" %}

A Page Table foi sacrificada para dar mais bit para o campo de Offset. Agora, uma entrada na Directory Table aponta para um tabela de 4 MiB.

Para encontrar o endereço base da estrutura de paginação, ele deve ser colocado no registrador CR3. Deve haver um alinhamento desse endereço baseado no tamanho de página que estrutura irá lidar. Para páginas de 4 KiB, o endereço deve zerar os 12 primeiros bits, e os 22 primeiros para 4 MiB. 

Essa mudança de tamanho não muda muita coisa, apenas que você agora está mexendo com páginas de 4 MiB. Mesmo com páginas de 4 KiB, uma PDE poderia apontar para uma Page Table que mapeasse até 4 MiB de memória, pois $$2^{10} \cdot 2^{12} = 4194304 = 2^{22}$$. O mesmo vale para o total de memória que pode ser endereçavel:

$$
2^{10} \cdot 2^{22} = 2^{32} = 4 \text{ GiB}
$$

Ou seja, a Page Table foi retirada e o Offset aumentou. Um vantagem é que precisamos apenas de uma única tabela de 4 KiB para mapear todo o kernel:

$$
2^{10} \cdot 4 = 4096
$$

# 2.2 - Uma breve introdução ao PAE

Com a Paginação PAE as coisas mudam um pouco, porque é adicionado mais um campo no endereço linear (Veja a Figura 2-4) e uma tabela de registradores, chamada de PDPT (_Page-Directory-Pointer-Table_).

{% include image_description.html src="/assets/img/mm/paging_structure_pae.png" caption="Figura 2-4: Formato do endereço linear para páginas de 4 KiB usando PAE" %}

Fazendo um calculo rápido verá que cada PDPTE pode mapear até 1 GiB de memória:

$$
2^{9} \cdot 2^{9} \cdot 2^{12} = 1073741824 = 1 \text{ GiB}
$$

Como são 4 registradores, então podemos mapear até 4 GiB, claro.

O PAE permite também que tabelas de 2 MiB sejam usadas, se a flag PS da PDE estiver igual a 1. Olhe a Figura 2-5 e você vera que a Page Table é tirada e agora temos 21 bits para o Offset, ou seja, $$2^{21} = 2097152 = 2 \text{ MiB}$$.

{% include image_description.html src="/assets/img/mm/paging_structure_pae_2mib.png" caption="Figura 2-5: Formato do endereço linear para páginas de 2 MiB usando PAE" %}

# 2.3 - Paginação de nível 4

Aqui será apenas uma apresentação rápida. Não irei falar da estrutura das entradas de tabela, mas você pode consultar isso na especificação.

Primeiramente, no modo longo, existe dois tipos de paginação: o de nível 4 e o de nível 5. O foco aqui será o primeiro. Com o nível 4, o endereço linear tem 48 bits de tamanho. Isso permite endereçar que até 256 TiB ($$2^{48}$$) de memória linear. Esse endereço linear pode ser traduzido para um endereço de até 52 bits. Mas, com 52 bits não seria possível endereçar até 4 PiB? Sim, mas apenas 256 TiB são possíveis de um vez, devido ao tamanho de 48 bits do endereço liner. Tecnicamente, você não vai encontrar uma memória RAM de 4 PiB, então não precisa se preocupar com isso.

No caso da paginação de nível 5, o endereço linear terá 57 bits de tamanho, ou seja, 128 PiB de memória linar. E o endereço físico pode ter até 52 bits, isto é, 4 PiB de memória física.

A estrutura de ambas as tabelas são mostradas na Figura 2-6.

{% include image_description.html src="/assets/img/mm/paging_structure_level_4.png" caption="Figura 2-6: Formato do endereço linear para páginas de 4 KiB usando paginação de nível 4." %}

# 3 - Paginação no Kernel Linux

Pode parecer estranho, mas o Linux não chama as tabelas de paginação como na especificação. É dado o nome de PGD, P4D, PUD, PMD e PTE para as tabelas PML5, PML4, PDPT, PD e PT, respectivamente. Isso faz sentido se você pensar que o kernel quer abstrair as várias arquiteturas que ele suporta. Em processadores diferentes da Intel, algo equivalente a PML5, por exemplo, não terá esse mesmo nome. O mesmo acontece com o expressão "linear address", que é chamado de "virtual address" no Linux.

# 3.1 - Configurações iniciais em modo protegido
A primeira vez que o Linux configura o espaço de endereço, em modo protegido, acontece no `arch/x86/kernel/head_32.S` (Veja a listagem 2-1).
```c
.Lenable_paging:

/*
 * Abilita a paginação
 */
	movl $pa(initial_page_table), %eax
	movl %eax,%cr3		/* Define o endereço base da estrutura.. */
	movl $CR0_STATE,%eax
	movl %eax,%cr0		/* ..E define o bit PG para abilitar a paginação */
	ljmp $__BOOT_CS,$1f
```
<p style="text-align: center;"><em>Listagem 2-1: Configuração da Paginação</em></p>

Veja que é colocado o endereço físico da estrutura em EAX e depois em CR3, porque o registrador CR3 não pode ser modificado, diretamente, através de um valor imediato. Depois, o `CR0_STATE`, uma valor com flags definidas, é movido para EAX. A Listagem 2-2 mostra como é a definição dessa macro. Veja que o bit PG é setado através de uma operação OR com a macro `X86_CR0_PG`. Por fim, um _long jump_ é necessário, pois o kernel precisa pular para o espaço de endereço configurado.

```c
...

#define X86_CR0_PG_BIT		31 /* Paginação */
/* A macro _BITUL() irá fazer a seguinte operação no caso abaixo:
 * 1UL << 31 = 0x80000000
 * Esse valor será usado para setar o bit PG em operação usando OR.
 */
#define X86_CR0_PG		_BITUL(X86_CR0_PG_BIT)

...

#define CR0_STATE	(X86_CR0_PE | X86_CR0_MP | X86_CR0_ET | \
			 X86_CR0_NE | X86_CR0_WP | X86_CR0_AM | \
			 X86_CR0_PG)

...
```
<p style="text-align: center;"><em>Listagem 2-2: Definição da macro CR0_STATE</em></p>

A definição do `initial_page_table` fica nesse mesmo arquivo. A Listagem 2-3 mostra um fragmento desse código.

```c
...

#ifdef  CONFIG_X86_PAE
#define KPMDS (((-__PAGE_OFFSET) >> 30) & 3) /* Número de PMDs */
	movl %eax,pa(initial_pg_pmd+0x1000*KPMDS-8)
#else
	movl %eax,pa(initial_page_table+0xffc)
#endif

...

#ifdef CONFIG_MITIGATION_PAGE_TABLE_ISOLATION
#define	PGD_ALIGN	(2 * PAGE_SIZE)
#define PTI_USER_PGD_FILL	1024
#else
#define	PGD_ALIGN	(PAGE_SIZE)
#define PTI_USER_PGD_FILL	0
#endif
/*
 * Seção BSS
 */
__PAGE_ALIGNED_BSS
	.align PGD_ALIGN
#ifdef CONFIG_X86_PAE
.globl initial_pg_pmd
initial_pg_pmd:
	.fill 1024*KPMDS,4,0
#else
.globl initial_page_table
initial_page_table:
	.fill 1024,4,0
#endif
	.align PGD_ALIGN
initial_pg_fixmap:
	.fill 1024,4,0
.globl swapper_pg_dir
	.align PGD_ALIGN
swapper_pg_dir:
	.fill 1024,4,0
	.fill PTI_USER_PGD_FILL,4,0
.globl empty_zero_page
empty_zero_page:
	.fill 4096,1,0
EXPORT_SYMBOL(empty_zero_page)

#ifdef CONFIG_X86_PAE
__PAGE_ALIGNED_DATA
        /* Page-aligned for the benefit of paravirt? */
        .align PGD_ALIGN
SYM_DATA_START(initial_page_table)
        .long   pa(initial_pg_pmd+PGD_IDENT_ATTR),0     /* low identity map */
# if KPMDS == 3
        .long   pa(initial_pg_pmd+PGD_IDENT_ATTR),0
        .long   pa(initial_pg_pmd+PGD_IDENT_ATTR+0x1000),0
        .long   pa(initial_pg_pmd+PGD_IDENT_ATTR+0x2000),0
# elif KPMDS == 2
        .long   0,0
        .long   pa(initial_pg_pmd+PGD_IDENT_ATTR),0
        .long   pa(initial_pg_pmd+PGD_IDENT_ATTR+0x1000),0
# elif KPMDS == 1
        .long   0,0
        .long   0,0
        .long   pa(initial_pg_pmd+PGD_IDENT_ATTR),0
# else
#  error "Kernel PMDs should be 1, 2 or 3"
# endif

...
```
<p style="text-align: center;"><em>Listagem 2-3: Definição da estrutura de paginação</em></p>.

O `.fill` é uma diretiva que irá alocar uma área de 1024 entradas com 4 bytes cada. É para isso que server o `1024` e `4` no parametro. O `0` é valor que cada entrada tera, ou seja, serão todas zeradas.

Note também que é feita uma comparação para verificar se o PAE está ativado. Se estiver, então o kernel irá usar a `initial_page_table` como uma tabela de registradores PDPT, na qual as entradas irão descrever o `initial_pg_pmd`, onde irá se comportar como uma Page Directory. Baseado na comparação acima, pode ser feito o mapeamente de 1 GiB, 2 GiB ou 3 GiB de memório para o Kernel.

Essas tabelas são configuradas em `arch/x86/kernel/head32.c` pela função `mk_early_pgtbl_32()` (Veja a Listagem 2-4).

```c
void __init __no_stack_protector mk_early_pgtbl_32(void)
{
	unsigned long limit = __pa_nodebug(_end) + (PAGE_TABLE_SIZE(LOWMEM_PAGES) << PAGE_SHIFT);
	pte_t pte, *ptep = (pte_t *)__pa_nodebug(__brk_base);
	struct boot_params __maybe_unused *params;
	pl2_t *pl2p = (pl2_t *)__pa_nodebug(pl2_base);
	unsigned long *ptr;

	pte.pte = PTE_IDENT_ATTR;
	pte = init_map(pte, &ptep, &pl2p, limit);

	ptr = (unsigned long *)__pa_nodebug(&max_pfn_mapped);
	*ptr = (pte.pte & PTE_PFN_MASK) >> PAGE_SHIFT;

	ptr = (unsigned long *)__pa_nodebug(&_brk_end);
	*ptr = (unsigned long)ptep + PAGE_OFFSET;

...

}
```
<p style="text-align: center;"><em>Listagem 2-4: Configuração da estrutura de paginação</em></p>.

A a função mostrada na Listagem 2-4 é responsáveil por criar e inicializar uma estrutura de paginação. Primeiro, veja a `__pa_nodebug()` na `mk_early_pgtbl_32()`, ele é uma macro usada para calcular o endereço físico a partir de um virtual. Quanto ao `PAGE_TABLE_SIZE()`, ele irá retornar o tamanho, em bytes, de um _page table_. No nosso caso acima, essa macro calcular um tamanho baseado em `LOWMEM_PAGES`, um macro que diz o tamanho do kernel. Por fim, é feito um _shift left_ com `PAGE_SHIFT` para simular uma multiplicação. Isso tudo resulta no limite da área que irá conter a page table que irá mapear o kernel.

Você pode ver o funcionamento dessas macros depois, mas resumindo é isso que acontece na macro `LOWMEM_PAGES`:

$$
((2 \ll 31) - \text{0xC0000000}) \gg 12 = 262144
$$

Esse primeiro calculo resulta no total de páginas do kernel. O 0xC0000000 pode variar dependendo do modo de operação (falaremos disso depois). Em seguida, é multiplicado por 4096 para calcular o tamanho, em bytes, do kernel:

$$
262144 \cdot 4096 = 1 \text{ GiB}
$$

Esses 1 GiB de páginas será colocado como entrada no `PAGE_TABLE_SIZE()`. Se você olhar essa macro, o seguinte calculo é feito:

$$
\dfrac{262144}{512} = 512
$$

Depois, perceba que é colocado o endereço `__brk_base` em `ptep`. Esse valor será usado como endereço base das _page tables_ usandas no mapeamento. Além disso, o endereço da tabela que irá descrever essas _page tables_ será atribuido na macro `pl2_base`, que é a nossa _directory table_ caso o PAE não esteja ativado. Se o PAE estiver habilitado, então `pl2_base` deve ser igual a `initial_pg_pmd`, caso contrário será `initial_page_table`. Esses valores são passados como argumento para a `init_map()`.

Na `init_map()` (Veja a Listagem 2-5), será feito um loop até que o endereço físico de `pte.pte` seja igual ao `limit`. Dentro desse loop, `pl2` receberá `ptep` mais o `PDE_IDENT_ATTR`, uma macro que permite setar o bit para definir uma entrada como presente, por exemplo (Veja a macro completo para ver as flags que são setadas). Em seguida, essa entrada é colocada na tabela apontada por `pl2p`, ou seja, essa entrada vai descrever uma _page table_. Logo depois será feito outro loop, que é usado para configurar a nova _page table_.

```c
#ifdef CONFIG_X86_PAE
typedef pmd_t                   pl2_t;
#define pl2_base                initial_pg_pmd
#define SET_PL2(val)            { .pmd = (val), }                                                                                     
#else
typedef pgd_t                   pl2_t;
#define pl2_base                initial_page_table
#define SET_PL2(val)            { .pgd = (val), }                                                                                     
#endif

static __init __no_stack_protector pte_t init_map(pte_t pte, pte_t **ptep, pl2_t **pl2p,
						  const unsigned long limit)
{
	while ((pte.pte & PTE_PFN_MASK) < limit) {
		pl2_t pl2 = SET_PL2((unsigned long)*ptep | PDE_IDENT_ATTR);
		int i;

		**pl2p = pl2;
		if (!IS_ENABLED(CONFIG_X86_PAE)) {
			/* Kernel PDE entry */
			*(*pl2p + ((PAGE_OFFSET >> PGDIR_SHIFT))) = pl2;
		}

		for (i = 0; i < PTRS_PER_PTE; i++) {
			**ptep = pte;
			pte.pte += PAGE_SIZE;
			(*ptep)++;
		}
		(*pl2p)++;
	}
	return pte;
}
```
<p style="text-align: center;"><em>Listagem 2-5: Função para fazer um mapeamento 1:1</em></p>.

Pronto, temos nosso kernel mapeado. Configurações futuras serão feitas mais para frente no código, mas por enquanto é isso.

# 3.2 - Configurações iniciais em modo longo
